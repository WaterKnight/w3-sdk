grammar j;
ARRAY: 'array';
ASSIGN: '=';
BOOL_TYPE: 'boolean';
BRACKET_LEFT: '[';
BRACKET_RIGHT: ']';
CALL: 'call';
CASE: 'case';
CODE_TYPE: 'code';
COMMA: ',';
CONSTANT: 'constant';
DEBUG: 'debug';
DEFAULT_CASE: 'default';
ELSE: 'else';
ELSEIF: 'elseif';
ENDFUNCTION: 'endfunction';
ENDGLOBALS: 'endglobals';
ENDIF: 'endif';
ENDLOOP: 'endloop';
ENDSELECT: 'endselect';
EXITWHEN: 'exitwhen';
EXTENDS: 'extends';
FUNCTION: 'function';
GLOBALS: 'globals';
HANDLE_TYPE: 'handle';
IF: 'if';
INT_TYPE: 'integer';
LOCAL: 'local';
LOOP: 'loop';
NATIVE: 'native';
NOTHING: 'nothing';
NULL: 'null';
PARENS_LEFT: '(';
PARENS_RIGHT: ')';
REAL_TYPE: 'real';
RETURN: 'return';
RETURNS: 'returns';
SELECT: 'select';
SET: 'set';
STRING_TYPE: 'string';
TAKES: 'takes';
THEN: 'then';
TYPE: 'type';
NEW_LINES: ('\r\n' | '\n' | '\r')+;
UNARY_OP: '+' | '-' | 'not';
INT: [1-9] [0-9]* | [0-9] | '0' [0-7]* | (('0' [xX]) | '$') [0-9a-fA-F]+ | '([\u0000-\u0026\u0028-\u00FF]+)';
REAL: ([0-9]+ '.' [0-9]*) | ('.' [0-9]+);
BOOL: 'true' | 'false';
STRING_LITERAL: '"' ( '\\' [abfnrtvz"'\\] | ~('\\'|'"'|'\r'|'\n') | NEW_LINES )* '"';
BINARY_OP: '+' | '-' | '*' | '/' | '==' | '!=' | '>' | '>=' | '<' | '<=' | 'and' | 'or';
ID: [a-zA-Z]([a-zA-Z0-9_]* [a-zA-Z0-9])?;
WS: (' ' | '\t')+ -> skip;
typedef: TYPE ID EXTENDS (HANDLE_TYPE | ID);
type: ID | CODE_TYPE | HANDLE_TYPE | INT_TYPE | REAL_TYPE | BOOL_TYPE | STRING_TYPE;
unary_op: UNARY_OP expr;
args_tail: COMMA expr;
args: expr args_tail*;
func_call: ID PARENS_LEFT args? PARENS_RIGHT;
array_ref: ID BRACKET_LEFT expr BRACKET_RIGHT;
funcRef: FUNCTION ID;
literal: INT | REAL | BOOL | STRING_LITERAL | NULL;
atomic_expr: unary_op | func_call | array_ref | funcRef | ID | literal;
expr: atomic_expr (BINARY_OP expr)? | (PARENS_LEFT expr PARENS_RIGHT);
var_declaration: (type ID (ASSIGN expr)?) | (type ARRAY ID);
global_var_list: ((CONSTANT type ARRAY? ID ASSIGN expr NEW_LINES) | (var_declaration NEW_LINES))*;
globals: GLOBALS NEW_LINES global_var_list ENDGLOBALS;
param_list: type ID (COMMA type ID)?;
func_declaration: ID TAKES (NOTHING | param_list) RETURNS (type | NOTHING);
native_func: CONSTANT? NATIVE func_declaration;
local_var_list: (LOCAL var_declaration NEW_LINES)*;
set: (SET ID ASSIGN expr) | (SET ID BRACKET_LEFT expr BRACKET_RIGHT ASSIGN expr);
call: CALL func_call;
else_if_clause: ELSEIF expr THEN NEW_LINES+ statement_list;
else_clause: (ELSE NEW_LINES+ statement_list) | (ELSEIF expr THEN NEW_LINES+ statement_list else_clause?);
if_then_else: IF expr THEN NEW_LINES+ statement_list else_if_clause* else_clause? ENDIF;
loop: LOOP NEW_LINES+ statement_list ENDLOOP;
exitwhen: EXITWHEN expr?;
return_statement: RETURN expr?;
debug: DEBUG statement;
case_clause: CASE expr NEW_LINES statement_list;
default_case_clause: DEFAULT_CASE NEW_LINES statement_list;
select: SELECT expr NEW_LINES case_clause* default_case_clause? NEW_LINES ENDSELECT;
statement: set | call | if_then_else | loop | exitwhen | return_statement | debug | select;
statement_list: (statement NEW_LINES)*;
func: CONSTANT? FUNCTION func_declaration NEW_LINES local_var_list statement_list ENDFUNCTION NEW_LINES;
declaration: typedef | globals | native_func | func;
file: NEW_LINES (declaration NEW_LINES)* func* NEW_LINES?;
program: file+;